<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>Liulu's blog</title>
 <link href="http://username.github.io/" rel="self"/>
 <link href="http://username.github.io"/>
 <updated>2014-03-29T17:06:14+08:00</updated>
 <id>http://username.github.io</id>
 <author>
   <name>Liu Lu</name>
   <email>liuluqqzj@qq.com</email>
 </author>

 
 <entry>
   <title>Use jekyll to manage your blog under Win7</title>
   <link href="http://username.github.io/git/ruby%20basic/2014/03/29/use-jekyll-to-manage-your-blog-under-win7"/>
   <updated>2014-03-29T00:00:00+08:00</updated>
   <id>http://username.github.io/git/ruby%20basic/2014/03/29/use-jekyll-to-manage-your-blog-under-win7</id>
   <content type="html">&lt;p&gt;若是不想折腾或者像我这样折腾了好久精疲力尽的人，可以参考本文秒速度安装jekyll. 老外搞的jekyll十足的蛋疼，使用ruby所编写，安装之前需要安装ruby，安装完ruby又是要版本管理工具RVM，又要开发环境DevKit，没准还要跑出一个python.安装过程问题不断，浪费大量时间配置环境。好了不废话了，好在老外提供了打包的解决方案，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1) 将一下的链接包下载下来：https://www.dropbox.com/sh/40l6mgbl1ce2kej/lF6ykQxt9d

2) 解压缩到本地的  D:\PortableJekyll 目录下。

3) 在Dos中执行 :   SET PATH=%PATH%;D:\PortableJekyll\ruby\bin;D:\PortableJekyll\devkit\bin;D:\PortableJekyll\git\bin;D:\PortableJekyll\Python\App;

4) 运行ruby -v 及jekyll -v 看是不是安装成功了，提示：命令在github shell 下可能不能执行。OK~~讲解完毕。。。&lt;/code&gt;&lt;/pre&gt;</content>
 </entry>
 
 <entry>
   <title>The research on pedometer algorithm</title>
   <link href="http://username.github.io/nrf51822%20development/2014/03/29/the-research-on-pedometer-algorithm"/>
   <updated>2014-03-29T00:00:00+08:00</updated>
   <id>http://username.github.io/nrf51822%20development/2014/03/29/the-research-on-pedometer-algorithm</id>
   <content type="html">&lt;p&gt;最近在开发一款手环，其必不可少的功能必然是计步。计步可能是手环中最基本但又很重要的一个功能，对于涉行未深的我来说还是有点小难度的，好在通过不断的查阅资料，采样波形总结，设计出了一个粗劣的计步算法。 由于手环在佩戴的时候位置并不固定，而且行走中抖动特别大，只通过一个三轴加速度计不太可能或者容易判断出人的运动轨迹。然而通过采样生成的曲线图，我们发现，当对其当前的各个轴加速度值求模之后，即modular = sqrt(x^2+y^2+z^2),模的采样值形成的曲线大体为一条类似正弦波，而且每隔一段时间有一个最大波谷（波峰），波谷数（波峰数）同步伐数相等。现在问题就很明朗了，我们只要数波谷（这里我选择的波谷）的个数即可求得所走的步伐数。 当然了，我们必须对条件的成立设置一些限定，否则会出现很大的判断失误。&amp;lt;未完，待续。。。&amp;gt;&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>solve the problem about Chinese encoding</title>
   <link href="http://username.github.io/git/ruby%20basic/2014/03/29/solve-the-problem-about-chinese-encoding"/>
   <updated>2014-03-29T00:00:00+08:00</updated>
   <id>http://username.github.io/git/ruby%20basic/2014/03/29/solve-the-problem-about-chinese-encoding</id>
   <content type="html">&lt;h2 id=&quot;error_invalid_byte_sequence_in_gbk&quot;&gt;解决中文编码问题：error: invalid byte sequence in GBK.&lt;/h2&gt;

&lt;p&gt;在文件路径：D:\Documents\Ruby200-x64\lib\ruby\gems\2.0.0\gems\jekyll-1.5.0\lib\jekyll 的文件：convertible.rb 。 在大概38行有这样一段代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;begin
	self.content = File.read_with_options(File.join(base, name),
	                     :encoding=&amp;gt;&amp;quot;utf-8&amp;quot;)  // 替换成utf-8编码
	          # merged_file_read_opts(opts))  // 此处注释掉了&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存，再编译，应该就没问题了。&lt;/p&gt;

&lt;h3 id=&quot;&quot;&gt;注意：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;本文采用Notepad++编辑。具体编码设定如下：
1）将编码改为：以UTF-8无BOM格式编码。
2）视图中-&amp;gt;显示符号-&amp;gt;显示所有符号，可以看到当前的换行符编码。
3）编辑-&amp;gt;档案格式转换-&amp;gt;转换为UNIX格式。&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;采用这种方式基本上能够解决中文编码出错的问题，本文就是这样处理的。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Single/double/long click recognition</title>
   <link href="http://username.github.io/nrf51822%20development/2014/03/29/singledoublelong-click-recognition"/>
   <updated>2014-03-29T00:00:00+08:00</updated>
   <id>http://username.github.io/nrf51822%20development/2014/03/29/singledoublelong-click-recognition</id>
   <content type="html">&lt;p&gt;题记：实现按键的单击这一单一功能可能会比较简单，但是要求识别多种操作就需要相对复杂的判断。对此，在大量占用CPU宝贵资源的提前下，本文中介绍了如何使用定时器中断及引脚中断的相互配合来实现按键响应的处理。 实现原理：1、可能大家常用的按键方式是拉低引脚电平来触发一次按键，在本文中采用的却是拉高引脚电平来触发一次按键。2、而在按键的过程中会出现“抖动”的情况，即按键按下的前几十毫秒引脚的电平跳变很厉害，采用延时10~20ms的方式再次检测引脚电平可避免抖动的影响。3、一次有效按键识别之后在其下降沿依次判断三种情况：a)这次按键是否超过2s，是则判为长按，结束。 b)否则，开启0.5s计时，0.5s内是否再次出现有效按键，是则判为双击，结束。c)否则，0.5s后超时，判为一次单击，结束。 具体实现如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1、 a)引脚初始化配置为输入下拉，上升沿中断。b)定时器配置为计时模式，同时将匹配寄存器的值根据当前滴答配置为CC[0] = 10ms， CC[3] = 0.5s，CC[1]用来计时；关闭定时器中断及定时器禁止。c）按键有效标识初始化为0，用来记录是否此次按键有效。此标识是长按、短按、双击成立的共同前提条件。

2、 引脚识别一个上升沿跳变触发引脚中断：在中断函数中进入上升沿处理区域，清除引脚中断位，关闭引脚中断并配置为下降沿；开启定时器10ms计时。

3、 定时器10ms匹配中断：关闭定时器中断，开启引脚中断。a)判断此时是否是高电平以及按键有效标识为0，是，则按键有效标识置1。b)判断此时是否是高电平以及按键有效标识为1,初次肯定不成立，后续处理见5。

4、 引脚识别一个下降沿跳变触发引脚中断：在中断函数中进入下降沿处理区域，清除引脚中断位，配置引脚中断为上升沿；a)捕获此时的定时器计时到CC[1]，是否大于2s并且按键有效标识为1，是，则判为长按，定时器中断关闭，定时器关闭，清除CC[1]，有效按钮标识清零。b）否a)，判断有效按钮标识是否为1，是，开启定时器0.5s计时。

5、 若0。5s内再次发生1、2、的情况，则依然进入3，此时按键有效标识已置1，则3中进入b处理: 执行到这里说明再次的按键有效在0.5s之内发生，判断为双击，定时器中断关闭，定时器关闭，清除CC[1]，有效按钮标识清零。

6、 0.5s计时中断触发：此时表明0.5s内未发生5，则视为超时未检测到二次按键，判为单击，定时器中断关闭，定时器关闭，清除CC[1]，有效按钮标识清零。&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;quot;button.h&amp;quot;
#include &amp;lt;stdbool.h&amp;gt;
#include &amp;lt;stdint.h&amp;gt;
#include &amp;quot;nrf.h&amp;quot;
#include &amp;quot;nrf_gpio.h&amp;quot;
#include &amp;quot;xprintf.h&amp;quot;

#define nRF_gpio_INT_pin         6     // 引脚(8)计时中断检测

static uint8_t button_tmp = 0;
// 0: nothing happened, 1:single-click, 2:double-click, 3:long-click 
static uint8_t BUTTON_STATE = 0;

//NRF_TIMER_Type * p_timer; //NRF_TIMER0/1/2
#define p_timer             NRF_TIMER0

// 中断事件处理函数
void GPIOTE_IRQHandler()
{
	 // Event causing the interrupt must be cleared.
	if((NRF_GPIOTE-&amp;gt;EVENTS_IN[0] == 1) &amp;amp;&amp;amp; (NRF_GPIOTE-&amp;gt;INTENSET &amp;amp; GPIOTE_INTENSET_IN0_Msk) &amp;amp;&amp;amp; (NRF_GPIOTE-&amp;gt;CONFIG[0] &amp;amp;  (GPIOTE_CONFIG_POLARITY_HiToLo &amp;lt;&amp;lt; GPIOTE_CONFIG_POLARITY_Pos) ) ) //上升沿
	{
		NRF_GPIOTE-&amp;gt;INTENSET  = GPIOTE_INTENSET_IN0_Disabled &amp;lt;&amp;lt; GPIOTE_INTENSET_IN0_Pos;     // 关GPIO引脚中断
		NRF_GPIOTE-&amp;gt;EVENTS_IN[0] = 0;
		NRF_GPIOTE-&amp;gt;CONFIG[0] =  (GPIOTE_CONFIG_POLARITY_LoToHi &amp;lt;&amp;lt; GPIOTE_CONFIG_POLARITY_Pos)
						   | (nRF_gpio_INT_pin &amp;lt;&amp;lt; GPIOTE_CONFIG_PSEL_Pos)  
						   | (GPIOTE_CONFIG_MODE_Event &amp;lt;&amp;lt; GPIOTE_CONFIG_MODE_Pos);
			   
		p_timer-&amp;gt;TASKS_CLEAR = 1;
		p_timer-&amp;gt;INTENSET       = TIMER_INTENSET_COMPARE0_Enabled &amp;lt;&amp;lt; TIMER_INTENSET_COMPARE0_Pos;   // 开通延时中断1
		p_timer-&amp;gt;TASKS_START = 1;
		//xprintf(&amp;quot;High INT.\r\n&amp;quot;);
	}
	// Event causing the interrupt must be cleared.
	if((NRF_GPIOTE-&amp;gt;EVENTS_IN[0] == 1) &amp;amp;&amp;amp; (NRF_GPIOTE-&amp;gt;INTENSET &amp;amp; GPIOTE_INTENSET_IN0_Msk) &amp;amp;&amp;amp; (NRF_GPIOTE-&amp;gt;CONFIG[0] &amp;amp;  (GPIOTE_CONFIG_POLARITY_LoToHi &amp;lt;&amp;lt; GPIOTE_CONFIG_POLARITY_Pos) ) )  // 下降沿
		{
			//xprintf(&amp;quot;Low INT.\r\n&amp;quot;);
		   // NRF_GPIOTE-&amp;gt;INTENSET  = GPIOTE_INTENSET_IN0_Disabled &amp;lt;&amp;lt; GPIOTE_INTENSET_IN0_Pos;     // 关GPIO引脚中断
			NRF_GPIOTE-&amp;gt;EVENTS_IN[0] = 0;
			NRF_GPIOTE-&amp;gt;CONFIG[0] =  (GPIOTE_CONFIG_POLARITY_HiToLo &amp;lt;&amp;lt; GPIOTE_CONFIG_POLARITY_Pos)
						   | (nRF_gpio_INT_pin &amp;lt;&amp;lt; GPIOTE_CONFIG_PSEL_Pos)  
						   | (GPIOTE_CONFIG_MODE_Event &amp;lt;&amp;lt; GPIOTE_CONFIG_MODE_Pos);
			
			p_timer-&amp;gt;TASKS_CAPTURE[1] = 1;  // 获取当前的定时器计时
			if( (p_timer-&amp;gt;CC[1] &amp;gt;= 28846) &amp;amp;&amp;amp; (button_tmp == 1) )   //  获得一次按键并且是长按
			{
				BUTTON_STATE = 3;
				button_tmp  = 0;
				p_timer-&amp;gt;TASKS_STOP = 1;
				p_timer-&amp;gt;TASKS_CLEAR = 1;
				p_timer-&amp;gt;INTENSET = TIMER_INTENSET_COMPARE0_Disabled &amp;lt;&amp;lt; TIMER_INTENSET_COMPARE0_Pos; // 关定时器延时中断0
				p_timer-&amp;gt;INTENSET = TIMER_INTENSET_COMPARE3_Disabled &amp;lt;&amp;lt; TIMER_INTENSET_COMPARE3_Pos; // 关延时中断
				xprintf(&amp;quot;Long click.\r\n&amp;quot;);
			}
			else
			{
				if(button_tmp == 1)    //  获得一次按键，但不是长按，开启1s 双击计时
				{
				   // p_timer-&amp;gt;TASKS_CLEAR = 1;
					//xprintf(&amp;quot;1s jishi.\r\n&amp;quot;);
					p_timer-&amp;gt;INTENSET      = TIMER_INTENSET_COMPARE3_Enabled &amp;lt;&amp;lt; TIMER_INTENSET_COMPARE3_Pos;   // 开延时中断2
				}
			}
		  //NRF_GPIOTE-&amp;gt;INTENSET  = GPIOTE_INTENSET_IN0_Set &amp;lt;&amp;lt; GPIOTE_INTENSET_IN0_Pos;     // 开GPIO引脚中断
		}
}
void TIMER0_IRQHandler()
{
	if((p_timer-&amp;gt;EVENTS_COMPARE[0] ==1) &amp;amp;&amp;amp; (p_timer-&amp;gt;INTENSET &amp;amp; TIMER_INTENSET_COMPARE0_Msk))     // 仅用来去抖延时
	{
		p_timer-&amp;gt;EVENTS_COMPARE[0] = 0;
		p_timer-&amp;gt;INTENSET = TIMER_INTENSET_COMPARE0_Disabled &amp;lt;&amp;lt; TIMER_INTENSET_COMPARE0_Pos; // 关定时器延时中断0
		//p_timer-&amp;gt;TASKS_CLEAR = 1;
		
		NRF_GPIOTE-&amp;gt;INTENSET  = GPIOTE_INTENSET_IN0_Enabled &amp;lt;&amp;lt; GPIOTE_INTENSET_IN0_Pos;     // 开GPIO引脚中断
		
		if((nrf_gpio_pin_read(8) &amp;amp; 1) &amp;amp;&amp;amp; (button_tmp == 0))     // 一次有效高电平
		{
			button_tmp = 1;
		   // xprintf(&amp;quot;one ok.\r\n&amp;quot;);
		}
		else 
		{
			if( (nrf_gpio_pin_read(8) &amp;amp; 1) &amp;amp;&amp;amp; (button_tmp == 1))     // 检测到两次有效高电平 结束
			{
				p_timer-&amp;gt;TASKS_STOP = 1;
				p_timer-&amp;gt;TASKS_CLEAR = 1;

				p_timer-&amp;gt;INTENSET = TIMER_INTENSET_COMPARE3_Enabled &amp;lt;&amp;lt; TIMER_INTENSET_COMPARE3_Disabled; // 关延时中断2
				BUTTON_STATE = 2;
				button_tmp = 0;
				xprintf(&amp;quot;Double click.\r\n&amp;quot;);
			}
		}
		//xprintf(&amp;quot;10ms.\r\n&amp;quot;);
	}
	if( (p_timer-&amp;gt;EVENTS_COMPARE[3] ==1) &amp;amp;&amp;amp; (p_timer-&amp;gt;INTENSET &amp;amp; TIMER_INTENSET_COMPARE3_Msk) &amp;amp;&amp;amp; (nrf_gpio_pin_read(8) == 0 )&amp;amp;&amp;amp; (button_tmp == 1))  // 1s延时中断到达，只检测到一次
	 {
		 p_timer-&amp;gt;EVENTS_COMPARE[3] = 0;
		 p_timer-&amp;gt;TASKS_STOP  = 1;
		 p_timer-&amp;gt;TASKS_CLEAR = 1;
		 p_timer-&amp;gt;INTENSET = TIMER_INTENSET_COMPARE0_Disabled &amp;lt;&amp;lt; TIMER_INTENSET_COMPARE0_Pos; // 关定时器延时中断0
		 p_timer-&amp;gt;INTENSET = TIMER_INTENSET_COMPARE3_Disabled &amp;lt;&amp;lt; TIMER_INTENSET_COMPARE3_Pos; // 关延时中断
		 BUTTON_STATE = 1;
		 button_tmp = 0;
		 xprintf(&amp;quot;Single click.\r\n&amp;quot;);
	 }
}

// gpio中断配置
void nRF_gpio_INT_config()
{
  nrf_gpio_cfg_input(nRF_gpio_INT_pin, NRF_GPIO_PIN_PULLUP);
	// Enable interrupt:
  NVIC_EnableIRQ(GPIOTE_IRQn);
   // 1,翻转 2,8引脚 3,事件模式
  NRF_GPIOTE-&amp;gt;CONFIG[0] =  (GPIOTE_CONFIG_POLARITY_HiToLo &amp;lt;&amp;lt; GPIOTE_CONFIG_POLARITY_Pos)
						   | (nRF_gpio_INT_pin &amp;lt;&amp;lt; GPIOTE_CONFIG_PSEL_Pos)  
						   | (GPIOTE_CONFIG_MODE_Event &amp;lt;&amp;lt; GPIOTE_CONFIG_MODE_Pos);
	//使能中断
  NRF_GPIOTE-&amp;gt;INTENSET  = GPIOTE_INTENSET_IN0_Set &amp;lt;&amp;lt; GPIOTE_INTENSET_IN0_Pos;
}


void button_start()
{
	// Start 16 MHz crystal oscillator.
	NRF_CLOCK-&amp;gt;EVENTS_HFCLKSTARTED  = 0;    // HFCLK oscillator state = 0.
	NRF_CLOCK-&amp;gt;TASKS_HFCLKSTART     = 1;    // Start HFCLK clock source

	// Wait for the external oscillator to start up.
	while (NRF_CLOCK-&amp;gt;EVENTS_HFCLKSTARTED == 0) 
	{
		// Do nothing.
	}
	p_timer-&amp;gt;MODE           = TIMER_MODE_MODE_Timer;        // Set the timer in Timer Mode.
	p_timer-&amp;gt;PRESCALER      = 9;                            // Prescaler 9 produces 31250 Hz timer frequency =&amp;gt; 1 tick = 32 us.
	p_timer-&amp;gt;BITMODE        = TIMER_BITMODE_BITMODE_32Bit;  // 16 bit mode.
	/* Bit 16 : Enable interrupt on COMPARE[0] */
	NVIC_EnableIRQ(TIMER0_IRQn);
	
	p_timer-&amp;gt;TASKS_CLEAR    = 1;                            // clear the task first to be usable for later.
	
	//
	p_timer-&amp;gt;CC[0]          = 288;    // 15ms延时
	p_timer-&amp;gt;CC[1]          = 0;
	p_timer-&amp;gt;CC[2]          = 0;
	p_timer-&amp;gt;CC[3]          = 9615;    // 0.5s延时
	
	// p_timer-&amp;gt;TASKS_START    = 1;                    // Start timer.

	
}&lt;/code&gt;&lt;/pre&gt;</content>
 </entry>
 
 <entry>
   <title>RTC clock initialization</title>
   <link href="http://username.github.io/nrf51822%20development/2014/03/29/rtc-clock-initialization"/>
   <updated>2014-03-29T00:00:00+08:00</updated>
   <id>http://username.github.io/nrf51822%20development/2014/03/29/rtc-clock-initialization</id>
   <content type="html">&lt;p&gt;在51822中，RTC的时钟为32.768kHZ, 它来源于LFCLK,手册上的描述为：The RTC will run off a low-frequency clock (LFCLK) running at 32.768 kHz. This clock may be either a RC oscillator or a crystal oscillator. The COUNTER resolution will therefore be 30.517 μs。而51822外部还接有一个32.768kHZ的时钟，所以在实际的选择当中，我们配置LFCLK为External 32KiHz crystal。 LFCLK为所有的低频率模块提供时钟源，所以一次性配置好以后就不要轻易的改变，以免引起其它模块的不正常。其初始化配置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NRF_CLOCK-&amp;gt;LFCLKSRC = (CLOCK_LFCLKSRC_SRC_Xtal &amp;lt;&amp;lt; CLOCK_LFCLKSRC_SRC_Pos);
NRF_CLOCK-&amp;gt;EVENTS_LFCLKSTARTED = 0;
NRF_CLOCK-&amp;gt;TASKS_LFCLKSTART = 1;
while (NRF_CLOCK-&amp;gt;EVENTS_LFCLKSTARTED == 0)
{
//Do nothing.
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于 NRF_CLOCK-&amp;gt;EVENTS_LFCLKSTARTED 这个标志位来说，当LFCLK时钟源开启时，它自动置为1，但是当你关闭LFCLK时，你需要手动将其置为0，这同其它的任何中断中需要将中断标志位清零是类似的道理。 此外RTC结构体中还提到一个功能，就是：Configures event enable routing to PPI for each RTC event。其含义为将内部的中断引出到外部接口（gpio）,意思就是：当内部的RTC发生一个中断时，所对应的gpio引脚可能产生一个脉冲或者电平的跳变。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>raspberry kernal compile</title>
   <link href="http://username.github.io/raspberry%20programming/2014/03/29/raspberry-kernal-compile"/>
   <updated>2014-03-29T00:00:00+08:00</updated>
   <id>http://username.github.io/raspberry%20programming/2014/03/29/raspberry-kernal-compile</id>
   <content type="html"></content>
 </entry>
 
 <entry>
   <title>PPI function in nRF51822</title>
   <link href="http://username.github.io/nrf51822%20development/2014/03/29/ppi-function-in-nrf51822"/>
   <updated>2014-03-29T00:00:00+08:00</updated>
   <id>http://username.github.io/nrf51822%20development/2014/03/29/ppi-function-in-nrf51822</id>
   <content type="html">&lt;p&gt;51822内部的PPI总线可以让一个事件的发生触发另外一个任务的执行，比如如下的这种配置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/** @brief Function for initializing the PPI peripheral.
*/
static void ppi_init(void)
{
// Configure PPI channel 0 to stop Timer 0 counter at TIMER1 COMPARE[0] match, which is every even number of seconds.
NRF_PPI-&amp;gt;CH[0].EEP = (uint32_t)(&amp;amp;NRF_TIMER1-&amp;gt;EVENTS_COMPARE[0]);
NRF_PPI-&amp;gt;CH[0].TEP = (uint32_t)(&amp;amp;NRF_TIMER0-&amp;gt;TASKS_STOP);
// Configure PPI channel 1 to start timer0 counter at TIMER2 COMPARE[0] match, which is every odd number of seconds.
NRF_PPI-&amp;gt;CH[1].EEP = (uint32_t)(&amp;amp;NRF_TIMER2-&amp;gt;EVENTS_COMPARE[0]);
NRF_PPI-&amp;gt;CH[1].TEP = (uint32_t)(&amp;amp;NRF_TIMER0-&amp;gt;TASKS_START);
// Enable only PPI channels 0 and 1.
NRF_PPI-&amp;gt;CHEN = (PPI_CHEN_CH0_Enabled &amp;lt;&amp;lt; PPI_CHEN_CH0_Pos) | (PPI_CHEN_CH1_Enabled &amp;lt;&amp;lt; PPI_CHEN_CH1_Pos);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;TIMER1产生一个事件匹配中断，产出一个脉冲，高电平为1，则会触发TIMER0的TASK_STOP被置1，TIMER0停止工作。我们还可以将所触发的任务设为gpio输出，这样就可以一个事件脉冲输出，作为一个中断信号。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>My first blog</title>
   <link href="http://username.github.io/diaries%20of%20ordinary%20life/2014/03/29/my-first-blog"/>
   <updated>2014-03-29T00:00:00+08:00</updated>
   <id>http://username.github.io/diaries%20of%20ordinary%20life/2014/03/29/my-first-blog</id>
   <content type="html">&lt;p&gt;This is my first blog. In my blog, I will record my life and my work.&lt;/p&gt;

&lt;p&gt;此乃吾之博客也。通阅此文，汝可闻吾闲暇碎语之乐，亦平日耕劳之作也。&lt;/p&gt;

&lt;p&gt;这是我的博客空间。在此博客中，我将会记录下来我的日常生活和工作心得。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                                                         ——刘璐
                                                         03/29/2014&lt;/code&gt;&lt;/pre&gt;</content>
 </entry>
 
 <entry>
   <title>Made a misstake today, so silly</title>
   <link href="http://username.github.io/nrf51822%20development/2014/03/29/made-a-misstake-today-so-silly"/>
   <updated>2014-03-29T00:00:00+08:00</updated>
   <id>http://username.github.io/nrf51822%20development/2014/03/29/made-a-misstake-today-so-silly</id>
   <content type="html">&lt;p&gt;又犯傻了。。。 Written by liulu on 三月 19, 2014 (Edit) 今天蓝牙协议启动不了，调试了半天，发现在定时器初始化之后就出错，对着定时器初始化代码看了半天也没发现异常。还把同事叫过来一起调试，最后自己发现了一个白痴的代码：NVIC_SetPriority(GPIOTE_IRQn, APP_IRQ_PRIORITY_LOW); 代码复制过来后忘记将GPIOTE_IRQn 改为TIMER1_IRQn ….导致协议栈初始化出错。。。。。又是出在小问题的处理上….不给力啊！！&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>how to build a blog</title>
   <link href="http://username.github.io/misc/2014/03/29/how-to-build-a-blog"/>
   <updated>2014-03-29T00:00:00+08:00</updated>
   <id>http://username.github.io/misc/2014/03/29/how-to-build-a-blog</id>
   <content type="html">&lt;p&gt;Read &lt;a href=&quot;http://jekyllbootstrap.com/usage/jekyll-quick-start.html&quot;&gt;Jekyll Quick Start&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Complete usage and documentation available at: &lt;a href=&quot;http://jekyllbootstrap.com&quot;&gt;Jekyll Bootstrap&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;update_author_attributes&quot;&gt;Update Author Attributes&lt;/h2&gt;

&lt;p&gt;In &lt;code&gt;_config.yml&lt;/code&gt; remember to specify your own data:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;title : My Blog =)

author :
  name : Name Lastname
  email : blah@email.test
  github : username
  twitter : username&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The theme should reference these variables whenever needed.&lt;/p&gt;

&lt;h2 id=&quot;sample_posts&quot;&gt;Sample Posts&lt;/h2&gt;

&lt;p&gt;This blog contains sample posts which help stage pages and blog data. When you don’t need the samples anymore just delete the &lt;code&gt;_posts/core-samples&lt;/code&gt; folder.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rm -rf _posts/core-samples&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here’s a sample “posts list”.&lt;/p&gt;
&lt;ul class=&#39;posts&#39;&gt;
  
    &lt;li&gt;&lt;span&gt;29 Mar 2014&lt;/span&gt; &amp;raquo; &lt;a href=&#39;/git/ruby%20basic/2014/03/29/use-jekyll-to-manage-your-blog-under-win7&#39;&gt;Use jekyll to manage your blog under Win7&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;29 Mar 2014&lt;/span&gt; &amp;raquo; &lt;a href=&#39;/nrf51822%20development/2014/03/29/the-research-on-pedometer-algorithm&#39;&gt;The research on pedometer algorithm&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;29 Mar 2014&lt;/span&gt; &amp;raquo; &lt;a href=&#39;/git/ruby%20basic/2014/03/29/solve-the-problem-about-chinese-encoding&#39;&gt;solve the problem about Chinese encoding&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;29 Mar 2014&lt;/span&gt; &amp;raquo; &lt;a href=&#39;/nrf51822%20development/2014/03/29/singledoublelong-click-recognition&#39;&gt;Single/double/long click recognition&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;29 Mar 2014&lt;/span&gt; &amp;raquo; &lt;a href=&#39;/nrf51822%20development/2014/03/29/rtc-clock-initialization&#39;&gt;RTC clock initialization&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;29 Mar 2014&lt;/span&gt; &amp;raquo; &lt;a href=&#39;/raspberry%20programming/2014/03/29/raspberry-kernal-compile&#39;&gt;raspberry kernal compile&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;29 Mar 2014&lt;/span&gt; &amp;raquo; &lt;a href=&#39;/nrf51822%20development/2014/03/29/ppi-function-in-nrf51822&#39;&gt;PPI function in nRF51822&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;29 Mar 2014&lt;/span&gt; &amp;raquo; &lt;a href=&#39;/diaries%20of%20ordinary%20life/2014/03/29/my-first-blog&#39;&gt;My first blog&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;29 Mar 2014&lt;/span&gt; &amp;raquo; &lt;a href=&#39;/nrf51822%20development/2014/03/29/made-a-misstake-today-so-silly&#39;&gt;Made a misstake today, so silly&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;29 Mar 2014&lt;/span&gt; &amp;raquo; &lt;a href=&#39;/misc/2014/03/29/how-to-build-a-blog&#39;&gt;how to build a blog&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;29 Mar 2014&lt;/span&gt; &amp;raquo; &lt;a href=&#39;/c%20programming/2014/03/29/errorxxx-has-already-been-declared-in-the-current-scope&#39;&gt;error xxx  has already been declared in the current scope&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;29 Mar 2014&lt;/span&gt; &amp;raquo; &lt;a href=&#39;/linux%20basic/2014/03/29/complie-linux-kernal&#39;&gt;Complie linux kernal&lt;/a&gt;&lt;/li&gt;
  
&lt;/ul&gt;
&lt;h2 id=&quot;todo&quot;&gt;To-Do&lt;/h2&gt;

&lt;p&gt;This theme is still unfinished. If you’d like to be added as a contributor, &lt;a href=&quot;http://github.com/plusjade/jekyll-bootstrap&quot;&gt;please fork&lt;/a&gt;! We need to clean up the themes, make theme usage guides with theme-specific markup examples.&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>error xxx  has already been declared in the current scope</title>
   <link href="http://username.github.io/c%20programming/2014/03/29/errorxxx-has-already-been-declared-in-the-current-scope"/>
   <updated>2014-03-29T00:00:00+08:00</updated>
   <id>http://username.github.io/c%20programming/2014/03/29/errorxxx-has-already-been-declared-in-the-current-scope</id>
   <content type="html">&lt;h3 id=&quot;&quot;&gt;问题处理：&lt;/h3&gt;

&lt;p&gt;出现这种问题的原因多半是自己的程序写的太过杂乱。各种头文件之间互相包含导致同一个文件或者函数调用重复编译报错。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;解决方法：在出错的头文件中添加#ifndef xxx  #define  xxx  #endif  的用法，如下所示：

头文件名为：xxx.h, 头文件内容编写为：
#ifndef  _XXX_H_
#define _XXX_H_
…
…
… 头文件代码
… 注意：变量不要定义在.h文件中
…
…
#endif
//空一行&lt;/code&gt;&lt;/pre&gt;</content>
 </entry>
 
 <entry>
   <title>Complie linux kernal</title>
   <link href="http://username.github.io/linux%20basic/2014/03/29/complie-linux-kernal"/>
   <updated>2014-03-29T00:00:00+08:00</updated>
   <id>http://username.github.io/linux%20basic/2014/03/29/complie-linux-kernal</id>
   <content type="html">&lt;p&gt;In this post, I will show you how to compile the kernal of linux.&lt;/p&gt;</content>
 </entry>
 
 
</feed>